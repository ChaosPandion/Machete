<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FParsec</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.CharParsers.NumberLiteralResultFlags">
<summary>
 Encodes various bits of information about a parsed number literal.
</summary>
</member>
<member name="">

</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar4">
<summary>
 Returns the fourth suffix char, or EOS if less than four suffix chars were parsed
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar3">
<summary>
 Returns the third suffix char, or EOS if less than three suffix chars were parsed
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar2">
<summary>
 Returns the second suffix char, or EOS if less than two suffix chars were parsed.
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar1">
<summary>
 Returns the first suffix char, or EOS if no suffix char was parsed.
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.String">
<summary>
 The parsed number literal string. Only includes the parsed suffix chars if the
 `NumberLiteralOptions` passed to the `numberLiteral` parser have the `IncludeSuffixCharsInString` flag set.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FParsec.CharParsers.NumberLiteral.Info">
<summary>
 Eencodes various bits of information on the string literal.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.CharParsers.NumberLiteral">
<summary>
 The return type of the `numberLiteral` parser. An instance contains the parsed
 number literal and various bits of information about it.
 Note that the `String` member contains the string literal without the suffix chars,
 except if the `NumberLiteralOptions` passed to the `numberLiteral` parser have the
 `IncludeSuffixCharsInString` flag set.
 Any parsed suffix chars are always available through the `SuffixChar1` - `4` members.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.CharParsers.NumberLiteralOptions">
<summary>
 Encodes the various options of the `numberLiteral` parser.
</summary>
</member>
<member name="T:FParsec.CharParsers.ParserResult`2.Failure">
<summary>
 Failure(errorAsString, error, suserState) holds the parser error and the user state returned by a failing parser,
 together with a string representation of the parser error.
</summary>
</member>
<member name="T:FParsec.CharParsers.ParserResult`2.Success">
<summary>
 Success(result, userState, endPos) holds the result and the user state returned by a successful parser,
 together with the position where the parser stopped.
</summary>
</member>
<member name="T:FParsec.CharParsers.ParserResult`2">
<summary>
 Values of this type are returned by the runParser functions (not by `Parser&lt;_,_&gt;` functions).
</summary>
</member>
<member name="M:FParsec.CharParsers.float32OfHexString(System.String)">
<summary>
 Returns the `float32` value represented by the given string in hexadecimal format.
 Raises a `System.FormatException` in case the string representation is invalid.
 Raises a `System.OverflowException` if the (absolute) value is too large to be represented by a `float32`.
</summary>
</member>
<member name="M:FParsec.CharParsers.float32ToHexString(System.Single)">
<summary>
 Returns a hexadecimal string representation of the `float32` argument.
</summary>
</member>
<member name="M:FParsec.CharParsers.floatOfHexString(System.String)">
<summary>
 Returns the `float` value represented by the given string in hexadecimal format.
 Raises a `System.FormatException` in case the string representation is invalid.
 Raises a `System.OverflowException` if the (absolute) value is too large to be represented by a `float`.
</summary>
</member>
<member name="M:FParsec.CharParsers.floatToHexString(System.Double)">
<summary>
 Returns a hexadecimal string representation of the `float` argument.
</summary>
</member>
<member name="M:FParsec.CharParsers.normalizeNewlines(System.String)">
<summary>
 `normalizeNewlines str` returns a version of `str`
 with all occurances of &quot;\r\n&quot; and &quot;\r&quot; replaced by &quot;\n&quot;.
 If the argument is `null`, `null` is returned.
</summary>
</member>
<member name="M:FParsec.CharParsers.foldCase(System.String)">
<summary>
 `foldCase str` returns a case-folded version of `str`
 with all chars mappend using the (non-Turkic) Unicode 1-to-1 case folding mappings
 for chars below 0x10000. If the argument is `null`, `null` is returned.
</summary>
</member>
<member name="P:FParsec.CharParsers.EOS">
<summary>
 `EOS` is equal to `CharStream.Iterator.EndOfStreamChar`.
</summary>
</member>
<member name="M:FParsec.CharParsers.previousCharSatisfiesNot``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `previousCharSatisfiesNot f` succeeds if the predicate function `f` returns `false`
 when applied to the char *before* the current char, otherwise it fails.
 If the current char is the first char in the stream, this parser succeeds (as opposed to `previousCharSatisfies`).
 This parser never changes the parser state.
 If the current char is the first char in the stream, the parser succeeds.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.previousCharSatisfies``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `previousCharSatisfies f` succeeds if the predicate function `f` returns `true`
 when applied to the char *before* the current char, otherwise it fails.
 If the current char is the first char in the stream, this parser fails (as opposed to `previousCharSatisfiesNot`).
 This parser never changes the parser state.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.currentCharSatisfiesNot``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `currentCharSatisfiesNot f` succeeds if the predicate function `f` returns `false`
 when applied to the current char, otherwise it fails.
 If the stream already has reached the end, this parser succeeds (as opposed to `currentCharSatisfies`).
 This parser never changes the parser state.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.currentCharSatisfies``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `currentCharSatisfies f` succeeds if the predicate function `f` returns `true`
 when applied to the current char, otherwise it fails.
 If the stream already has reached the end, this parser fails (as opposed to `currentCharSatisfiesNot`).
 This parser never changes the parser state.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.nextCharSatisfiesNot``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `nextCharSatisfiesNot f` succeeds if the predicate function `f` returns `false`
 when applied to the char *after* the current char, otherwise it fails.
 If there is no char after the current char, this parser succeeds (as opposed to `nextCharSatisfies`).
 This parser never changes the parser state.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.nextCharSatisfies``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `nextCharSatisfies f` succeeds if the predicate function `f` returns `true`
 when applied to the char *after* the current char, otherwise it fails.
 If there is no char after the current char, this parser fails (as opposed to `nextCharSatisfiesNot`).
 This parser never changes the parser state.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByStringCI``1(System.String)">
<summary>
 `notFollowedByStringCI str` is an optimized implementation of `notFollowedByL (pstringCI str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByString``1(System.String)">
<summary>
 `notFollowedByString str` is an optimized implementation of `notFollowedByL (pstring str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.followedByStringCI``1(System.String)">
<summary>
 `followedByStringCI str` is an optimized implementation of `followedByL (pstringCI str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.followedByString``1(System.String)">
<summary>
 `followedByString str` is an optimized implementation of `followedByL (pstring str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByChar``1(System.Char)">
<summary>
 `notFollowedByChar c` is an optimized implementation of `notFollowedByL (pchar c) (&quot;&apos;&quot; + c.ToString() + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.followedByChar``1(System.Char)">
<summary>
 `followedByChar c` is an optimized implementation of `followedByL (pchar c) (&quot;&apos;&quot; + c.ToString() + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint8``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than 255.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint16``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.UInt16.MaxValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint32``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.UInt32.MaxValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint64``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.UInt64.MaxValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint8``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than 127 or less than -128.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint16``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.Int16.MaxValue` or less than `System.Int16.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint32``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.Int32.MaxValue` or less than `System.Int32.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint64``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.Int64.MaxValue` or less than `System.Int64.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pfloat``1">
<summary>
 Parses a floating-point number in decimal or hexadecimal format.
 The special values NaN and Inf(inity)? (case insensitive) are also recognized.

 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in &quot;0x&quot;) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after &quot;0x&quot;,
 after consuming input, if the value represented by the input string (after rounding) is greater than `System.Double.MaxValue` or less than `System.Double.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.numberLiteralE``1(FParsec.CharParsers.NumberLiteralOptions,FParsec.Error.ErrorMessageList,FParsec.State{``0})">
<summary>
 `numberLiteralE` is an uncurried version of `numberLiteral` that can be used to
 implement number parsers without having to construct a `numberLiteral` closure.
</summary>
</member>
<member name="M:FParsec.CharParsers.numberLiteral``1(FParsec.CharParsers.NumberLiteralOptions,System.String)">
<summary>
 `numberLiteral options label` parses a number literal and returns the result in form
 of a `NumberLiteral` value. The given `NumberLiteralOptions` argument determines the kind
 of number literals accepted. The string `label` is used in the `Expected` error message
 that is generated when the parser fails without consuming input.

 The parser fails without consuming input, if not at least one digit (including the 0 in the
 format specifiers &quot;0x&quot; etc.) can be parsed. It fails after consuming input, if no decimal
 digit comes after an exponent marker or no valid digit comes after a format specifier.
</summary>
</member>
<member name="M:FParsec.CharParsers.withSkippedString``3(Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``0,``2}})">
<summary>
 `p |&gt; withSkippedString f` applies the parser `p` and returns the result of `f str x`,
 where `str` is the string skipped over by `p` and `x` is the result returned by `p`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipped``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{Microsoft.FSharp.Core.Unit,``0}})">
<summary>
 `skipped p` applies the parser `p` and returns the chars skipped over by `p` as a string.
 All newlines (&quot;\r\n&quot;, &quot;\r&quot; or &quot;\n&quot;) are normalized to &quot;\n&quot;.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Strings2``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.String,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.String,``0}})">
<summary>
 `many1Strings2 sp1 sp` behaves like `many1Strings sp`, except that it parses the first string with `sp1` instead of `sp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Strings``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.String,``0}})">
<summary>
 `many1Strings sp` parses a sequence of *one* or more strings with the string parser `sp`.
 It returns the strings in concatenated form.
 Note that `many1Strings sp` does not require the first string to be non-empty.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyStrings2``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.String,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.String,``0}})">
<summary>
 `manyStrings2 sp1 sp` behaves like `manyStrings sp`, except that it parses the first string with `sp1` instead of `sp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyStrings``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.String,``0}})">
<summary>
 `manyStrings sp` parses a sequence of *zero* or more strings with the string parser `sp`.
 It returns the strings in concatenated form.
 `manyStrings sp` is an optimized implementation of `manyReduce (+) &quot;&quot; sp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1CharsTill2``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 `skipMany1CharsTill2 cp1 cp endp` is an optimized implementation of `many1CharsTill2 cp1 cp endp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1CharsTill``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 `skipMany1CharsTill cp endp` is an optimized implementation of `many1CharsTill cp endp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTillApply2``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 `many1CharsTillApply2 cp1 cp endp` behaves like `many1CharsTillApply cp endp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTillApply``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 `many1CharsTillApply cp endp` parses one char with the char parser `cp`.
 Then it parses more chars with `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the result of the function application `f str b`,
 where `str` is the parsed string and `b` is result returned by `endp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTill2``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{``1,``0}})">
<summary>
 `many1CharsTill2 cp1 cp endp` behaves like `many1CharsTill cp endp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTill``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{``1,``0}})">
<summary>
 `many1CharsTill cp endp` parses one char with the char parser `cp`.
 Then it parses more chars with `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the parsed chars as a string.

 `many1CharsTill cp endp` is an optimized implementation of `pipe2 cp (manyCharsTill cp endp) (fun c1 str -&gt; c1.ToString() + str)`
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyCharsTill``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 `skipManyCharsTill cp endp` is an optimized implementation of `manyCharsTill cp endp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyCharsTillApply``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 `manyCharsTillApply cp endp f` parses chars with the char parser `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the result of the function application `f str b`,
 where `str` is the parsed string and `b` is result returned by `endp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyCharsTill``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{``1,``0}})">
<summary>
 `manyCharsTill cp endp` parses chars with the char parser `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the parsed chars as a string.

 `manyCharsTill cp endp` is an optimized implementation of `manyTill cp endp` that returns the chars as a string instead of a char list.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Chars2``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 `skipMany1Chars2 cp1 cp` is an optimized implementation of `many1Chars2 cp1 cp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Chars``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 `skipMany1Chars cp` is an optimized implementation of `many1Chars cp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Chars2``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}})">
<summary>
 `many1Chars2 cp1 cp` behaves like `many1Chars2 cp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Chars``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}})">
<summary>
 `many1Chars cp` parses a sequence of *one* or more chars with the char parser `cp`.
 It returns the parsed chars as a string.

 `many1Chars cp` is an optimized implementation of `many1 (attempt cp)` that returns
 the chars as a string instead of a char list.  The equivalence to `many1 (attempt p)`
 instead of `many1 p` implies that  `many1Chars` never fails after consuming input.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyChars2``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 `skipManyChars2 cp1 cp` is an optimized implementation of `manyChars2 cp1 cp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyChars``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 `skipManyChars cp` is an optimized implementation of `manyChars cp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyChars2``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}})">
<summary>
 `manyChars2 cp1 cp` behaves like `manyChars2 cp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyChars``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``0},FParsec.Primitives.Reply{System.Char,``0}})">
<summary>
 `manyChars cp` parses a sequence of *zero* or more chars with the char parser `cp`.
 It returns the parsed chars as a string.

 `manyChars cp` is an optimized implementation of `many (attempt cp)` that returns
 the chars as a string instead of a char list.  The equivalence to `many (attempt p)`
  instead of `many p` implies that `manyChars` never fails.
</summary>
</member>
<member name="M:FParsec.CharParsers.regex``1(System.String)">
<summary>
 `regex pattern` matches the .NET regular expression given by the string `pattern` on the chars
 beginning at the current index in the input stream. It returns the string matched by the regular expression.
 If the regular expression does not match, the parser fails without consuming input.

 The `System.Text.RegularExpressions.Regex` object that is internally used to match the pattern is constructed
 with the `RegexOptions` `MultiLine` and `ExplicitCapture`. In order to ensure that the regular expression
 can only match at the beginning of a string, `&quot;\\A&quot;` is automatically prepended to the pattern.

 Newline chars (&apos;\r&apos; and &apos;\n&apos;) in the pattern are interpreted literally.
 For example, an &apos;\n&apos; char in the pattern will only match &quot;\n&quot;, not &quot;\r&quot; or &quot;\r\n&quot;.
 However, in the returned string all newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are normalized to &quot;\n&quot;.

 For large files the regular expression is *not* applied to a string containing *all* the remaining chars
 in the stream. The number of chars that are guaranteed to be visible to the regular expression is specified
 during construction of the `CharStream`. If one of the `runParser` function` is used to run the parser,
 this number is 43690.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfy2L``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `skipManyMinMaxSatisfy2L nMin nMax f1 f label` is an optimized implementation of `skipManyMinMaxSatisfy2 nMin nMax f1 f &lt;|&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfyL``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `skipManyMinMaxSatisfyL nMin nMax f label` is an optimized implementation of `skipManyMinMaxSatisfy nMin nMax f &lt;|&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfy2L``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `manyMinMaxSatisfy2L nMin nMax f1 f label` is an optimized implementation of `manyMinMaxSatisfy2 nMin nMax f1 f &lt;|&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfyL``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `manyMinMaxSatisfyL nMin nMax f label` is an optimized implementation of `manyMinMaxSatisfy nMin nMax f &lt;|&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfy2``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipManyMinMaxSatisfy2 nMin nMax f1 f` is an optimized implementation of `manyMinMaxSatisfy2 nMin nMax f1 f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfy``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipManyMinMaxSatisfy nMin nMax f` is an optimized implementation of `manyMinMaxSatisfy nMin nMax f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfy2``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `manyMinMaxSatisfy2 nMin nMax f1 f` behaves like `manyMinMaxSatisfy nMin nMax f`, except that the first char of the parsed string must satisfy `f1` instead of `f`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfy``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `manyMinMaxSatisfy nMin nMax f` parses a sequence of `nMin` or more chars that satisfy the
 predicate function `f` (i.e. chars for which `f` returns `true`), but not more than `nMax` chars.
 It returns the parsed chars as a string. This parser is atomic, i.e. if the first `nMin` chars
 do not all satisfy `f`, the parser fails without consuming any input.

 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called with &apos;\r&apos;
 and the string returned by `manyMinMaxSatisfy nMin nMax f` will never contain an &apos;\r&apos;.

 `manyMinMaxSatisfy` throws an `ArgumentOutOfRangeException` if `nMax` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Satisfy2L``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `skipMany1Satisfy2L f1 f label` is an optimized implementation of `skipMany1Satisfy2 f1 f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1SatisfyL``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `skipMany1SatisfyL f label` is an optimized implementation of `skipMany1Satisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Satisfy2L``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `many1Satisfy2L f1 f label` is an optimized implementation of `many1Satisfy2 f1 f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1SatisfyL``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `many1SatisfyL f label` is an optimized implementation of `many1Satisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Satisfy2``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipMany1Satisfy2 f1 f` is an optimized implementation of `many1Satisfy2 f1 f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Satisfy``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipMany1Satisfy f` is an optimized implementation of `many1Satisfy f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Satisfy2``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `many1Satisfy2 f1 f` behaves like `many1Satisfy f`, except that the
 first char of the parsed string must satisfy `f1` instead of `f`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Satisfy``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `many1Satisfy f` parses a sequence of *one* or more chars that satisfy the predicate function `f`
 (i.e. chars for which `f` returns `true`). It returns the parsed chars as a string.
 If the first char does not satisfy `f`, this parser fails without consuming input.

 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called
 with &apos;\r&apos; and the string returned by `many1Satisfy f` will never contain an &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManySatisfy2``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipManySatisfy2 f1 f` is an optimized implementation of `manySatisfy2 f1 f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManySatisfy``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipManySatisfy f` is an optimized implementation of `manySatisfy f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manySatisfy2``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `manySatisfy2 f1 f` behaves like `manySatisfy f`, except that the
 first char of the parsed string must satisfy `f1` instead of `f`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manySatisfy``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `manySatisfy f` parses a sequence of *zero* or more chars that satisfy the predicate function `f`
 (i.e.  chars for which `f` returns `true`). It returns the parsed chars as a string.

 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called
 with &apos;\r&apos; and the string returned by `manySatisfy f` will never contain an &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipCharsTillStringCI``1(System.String,System.Int32)">
<summary>
 `skipCharsTillStringCI str nMax` is an optimized implementation of `charsTillStringCI str nMax |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.charsTillStringCI``1(System.String,System.Int32)">
<summary>
 `charsTillStringCI str nMax` parses all chars before the first case-insensitive occurance of the string `str`
 and then skips over it. It returns the parsed chars before the string.
 If more than `nMax` chars come before the first case-insensitive occurance of `str`,
 the parser *fails* after consuming `nMax` chars.
 Newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are counted as single chars and
 in the returned string all newlines are normalized to &quot;\n&quot;.
 `charsTillStringCI str nMax` throws an `ArgumentOutOfRangeException` if `nMax` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipToStringCI``1(System.String,System.Int32)">
<summary>
 `skipToStringCI str nMax` skips over all chars before the first case-insensitive occurance of the string `str`.
 If more than `nMax` chars come before the first case-insensitive occurance of `str`,
 the parser *fails after consuming* `nMax` chars.
 Newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are counted as single chars.
 `skipToStringCI str nMax` throws an `ArgumentOutOfRangeException` if `nMax` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipCharsTillString``1(System.String,System.Int32)">
<summary>
 `skipCharsTillString str nMax` is an optimized implementation of `charsTillString str nMax |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.charsTillString``1(System.String,System.Int32)">
<summary>
 `charsTillString str nMax` parses all chars before the first occurance of the string `str`and
 then skips over `str`. It returns the parsed chars before the string.
 If more than `nMax` chars  come before the first occurance of `str`, the parser *fails after consuming* `nMax` chars.
 Newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are counted as single chars and
 in the returned string all newlines are normalized to &quot;\n&quot;.
 `charsTillString str nMax` throws an `ArgumentOutOfRangeException` if `nMax` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipToString``1(System.String,System.Int32)">
<summary>
 `skipToString str nMax` skips over all chars before the first occurance of the string `str`.
 If more than `nMax` chars come before the first occurance of `str`, the parser *fails after consuming* `nMax` chars.
 Newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are counted as single chars.
 `skipToString str nMax` throws an `ArgumentOutOfRangeException` if `nMax` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipToEndOfLine``1">
<summary>
 Skips over any chars before the end of the line. Stops before the newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)
 or at the end of the input stream if there is no newline.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipRestOfLine``1">
<summary>
 `skipRestOfLine` is an optimized implementation of `restOfLine |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.restOfLine``1">
<summary>
 Parses any chars before the end of the line and skips to the beginning of the next line (if there is one).
 The line is terminated by a newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) or the end of the input stream.
 Returns the parsed chars before the end of the line as a string (without a newline).
</summary>
</member>
<member name="M:FParsec.CharParsers.skipAnyString``1(System.Int32)">
<summary>
 `skipAnyString n` is an optimized implementation of `anyString n |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.anyString``1(System.Int32)">
<summary>
 `anyString n` parses any sequence of `n` chars or newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;).
 It returns the parsed string. In the returned string all newlines are normalized to &quot;\n&quot;.
 `anyString n` is an atomic parser: either it succeeds or it fails without consuming any input.
</summary>
</member>
<member name="M:FParsec.CharParsers.stringCIReturn``2(System.String,``0)">
<summary>
 `stringCIReturn str x` is an optimized implementation of `pstringCI str &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipStringCI``1(System.String)">
<summary>
 `skipStringCI str` is an optimized implementation of `pstringCI str |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pstringCI``1(System.String)">
<summary>
 `pstringCI str` parses any string that case-insensitively matches the string `str`.
 It returns the *parsed* string.
 `str` may not contain newline chars (`&apos;\n&apos;` or `&apos;\r&apos;`).
</summary>
</member>
<member name="M:FParsec.CharParsers.stringReturn``2(System.String,``0)">
<summary>
 `stringReturn str x` is an optimized implementation of `pstring str &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipString``1(System.String)">
<summary>
 `skipString str` is an optimized implementation of `pstring str |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pstring``1(System.String)">
<summary>
 `pstring str` parses the string `str` and returns `str`.
 It is an atomic parser: either it succeeds or it fails without consuming any input.
 `str` may not contain newline chars (`&apos;\n&apos;` or `&apos;\r&apos;`).
</summary>
</member>
<member name="M:FParsec.CharParsers.eof``1">
<summary>
 The parser `eof` only succeeds at the end of the input. It never consumes input.
</summary>
</member>
<member name="M:FParsec.CharParsers.spaces1``1">
<summary>
 Skips over any sequence of *one* or more whitespaces (space (&apos; &apos;), tab(&apos;\t&apos;)
 or newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)).
</summary>
</member>
<member name="M:FParsec.CharParsers.spaces``1">
<summary>
 Skips over any sequence of *zero* or more whitespaces (space (&apos; &apos;), tab (&apos;\t&apos;)
 or newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)).
</summary>
</member>
<member name="M:FParsec.CharParsers.unicodeWhitespace``1">
<summary>
 Parses a unicode newline (&quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, `&quot;\u0085&quot;`, `&quot;\u000C&quot;`,
 `&quot;\u2028&quot;`, or `&quot;\u2029&quot;`) or any whitespace char identified by `System.Char.IsWhiteSpace`.
 Returns &apos;\n&apos; for a newline and otherwise the parsed char.
 In contrast to all other parsers in FParsec except `unicodeNewline` this parser
 also increments the internal line count for unicode newline characters other than &apos;\n&apos; and &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.whitespace``1">
<summary>
 Parses a space (&apos; &apos;), a tab (&apos;\t&apos;) or a newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;).
 Returns &apos;\n&apos; for a newline and otherwise the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.unicodeNewline``1">
<summary>
 Parses a unicode newline (&quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, `&quot;\u0085&quot;`, `&quot;\u000C&quot;`, `&quot;\u2028&quot;`, or `&quot;\u2029&quot;`).
 Returns &apos;\n&apos;.
 In contrast to all other parsers in FParsec except `unicodeWhitespace` this parser
 also increments the internal line count for unicode newline characters other than &apos;\n&apos; and &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.newlineReturn``2(``0)">
<summary>
 `newlineReturn x` is an optimized implementation of `newline &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipNewline``1">
<summary>
 `skipNewline` is an optimized implementation of `newline |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.newline``1">
<summary>
 Parses a newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;). Returns &apos;\n&apos;.
 Is equivalent to `pchar &apos;\n&apos;`.
</summary>
</member>
<member name="M:FParsec.CharParsers.tab``1">
<summary>
 Parses the tab char &apos;\t&apos; and returns &apos;\t&apos;. Note that a tab char is treated like any other non-newline char:
 the column number is incremented by (only) 1.
</summary>
</member>
<member name="M:FParsec.CharParsers.isOctal(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;0&apos; - &apos;7&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isHex(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;0&apos; - &apos;9&apos;, &apos;a&apos; - &apos;f&apos;, &apos;A&apos; - &apos;F&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isDigit(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;0&apos; - &apos;9&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isLetter(System.Char)">
<summary>
 `isLetter` is equivalent to `System.Char.IsLetter`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isLower(System.Char)">
<summary>
 `isLower` is equivalent to `System.Char.IsLower`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isUpper(System.Char)">
<summary>
 `isUpper` is equivalent to `System.Char.IsUpper`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAsciiLetter(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;a&apos; - &apos;z&apos;, &apos;A&apos; - &apos;Z&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAsciiLower(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;a&apos; - &apos;z&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAsciiUpper(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;A&apos; - &apos;Z&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isNoneOf(System.String)">
<summary>
 `isNoneOf str` returns a predicate function.
 When this predicate function is applied to a char, it returns `true` if and only if the char is not contained in `str`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAnyOf(System.String)">
<summary>
 `isAnyOf str` returns a predicate function.
 When this predicate function is applied to a char, it returns `true` if and only if the char is contained in `str`.
</summary>
</member>
<member name="M:FParsec.CharParsers.octal``1">
<summary>
 Parses any char in the range &apos;0&apos; - &apos;7&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.hex``1">
<summary>
 Parses any char in the range &apos;0&apos; - &apos;9&apos;, &apos;a&apos; - &apos;f&apos; and &apos;A&apos; - &apos;F&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.digit``1">
<summary>
 Parses any char in the range &apos;0&apos; - &apos;9&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.letter``1">
<summary>
 Parses any unicode letter char identified by `System.Char.IsLetter`.
 Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.lower``1">
<summary>
 Parses any unicode lowercase letter char identified by `System.Char.IsLower`.
 Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.upper``1">
<summary>
 Parses any unicode uppercase letter char identified by `System.Char.IsUpper`.
 Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.asciiLetter``1">
<summary>
 Parses any char in the range &apos;a&apos; - &apos;z&apos; and &apos;A&apos; - &apos;Z&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.asciiLower``1">
<summary>
 Parses any char in the range &apos;a&apos; - &apos;z&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.asciiUpper``1">
<summary>
 Parses any char in the range &apos;A&apos; - &apos;Z&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipNoneOf``1(System.String)">
<summary>
 `skipNoneOf s` is an optimized implementation of `noneOf s |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.noneOf``1(System.String)">
<summary>
 `noneOf str` parses any char not contained in the string `str`. It returns the parsed char.
 If `str` does not contain the char &apos;\n&apos;, `noneOf str` parses any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)
 and returns it as  as &apos;\n&apos;. (Note that it does not make a difference whether or not
 `str` contains &apos;\r&apos;; `noneOf str` will never return &apos;\r&apos;.)
</summary>
</member>
<member name="M:FParsec.CharParsers.skipAnyOf``1(System.String)">
<summary>
 `skipAnyOf str` is an optimized implementation of `anyOf str |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.anyOf``1(System.String)">
<summary>
 `anyOf str` parses any char contained in the string `str`. It returns the parsed char.
 If `str` contains the char &apos;\n&apos;, `anyOf str` parses any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)
 and returns it as &apos;\n&apos;. (Note that it does not make a difference whether or not
 `str` contains &apos;\r&apos;; `anyOf str` will never return &apos;\r&apos;.)
</summary>
</member>
<member name="M:FParsec.CharParsers.skipSatisfyL``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `skipSatisfyL f label` is an optimized implementation of `skipSatisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.satisfyL``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 `satisfy f label` is an optimized implementation of `satisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipSatisfy``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `skipSatisfy f` is an optimized implementation of `satisfy f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.satisfy``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean})">
<summary>
 `satisfy f` parses any one char or newline for which the predicate function `f` returns `true`.
 It returns the parsed char.
 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called
 with &apos;\r&apos; and `satisfy f` will never return &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipAnyChar``1">
<summary>
 `skipAnyChar` is an optimized implementation of `anyChar |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.anyChar``1">
<summary>
 `anyChar` parses any single char or newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;).
 Returns the parsed char, or &apos;\n&apos; in case a newline was parsed.
</summary>
</member>
<member name="M:FParsec.CharParsers.charReturn``2(System.Char,``0)">
<summary>
 `charReturn c x` is an optimized implementation of `pchar c &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipChar``1(System.Char)">
<summary>
 `skipChar c` is an optimized implementation of `pchar c |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pchar``1(System.Char)">
<summary>
 `pchar c` parses the char `c` and returns `c`.
 If `c = &apos;\r&apos;` or `c = &apos;\n&apos;` then `pchar c` will parse any one newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) and return `c`.
</summary>
</member>
<member name="M:FParsec.CharParsers.userStateSatisfies``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean})">
<summary>
 The parser `userStateSatisfies f` succeeds if `f` returns `true`
 when applied to the current user state, otherwise it fails.
</summary>
</member>
<member name="M:FParsec.CharParsers.updateUserState``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,``0})">
<summary>
 `updateUserState f` is equivalent to `fun state -&gt; Reply((), state.WithUserState(f state.UserState))`.
</summary>
</member>
<member name="M:FParsec.CharParsers.setUserState``1(``0)">
<summary>
 The parser `setUserState u` sets the user state to `u`.
 `setUserState u` is equivalent to `fun state -&gt; Reply((), state.WithUserState(u))`.
</summary>
</member>
<member name="M:FParsec.CharParsers.getUserState``1">
<summary>
 The parser `getUserState` returns the current user state.
 `getUserState` is equivalent to `fun state -&gt; Reply(state.UserState, state)`.
</summary>
</member>
<member name="">

</member>
<member name="M:FParsec.CharParsers.getPosition``1">
<summary>
 The parser `getPosition` returns the current position in the input Stream.
 `getPosition` is equivalent to `fun state -&gt; Reply(state.Position, state)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.run``1(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{Microsoft.FSharp.Core.Unit},FParsec.Primitives.Reply{``0,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 `run parser str` is equivalent to `runParserOnString parser () &quot;&quot; str`.
 This function is mainly meant for testing purposes or interactive usage.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnSubstream``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``1,FParsec.State{``2},FParsec.State{``2})">
<summary>
 `runParserOnSubStream p stateBegin stateEnd` runs the parser `p` on the `CharStream` content
 between the position of `stateBegin` (inclusive) and `stateEnd` (exclusive). The substream appears
 to the parser as a new and independent stream, although the position information
 (index, column and line count etc.) reflects the position within the original stream.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.

 If the underlying `CharStream` has more than one block, `runParserOnSubStream` will copy
 the content of the substream before applying the parser.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnFile``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``1,System.String,System.Text.Encoding)">
<summary>
 `runParserOnFile p ustate path encoding` runs the parser `p` on the content of the file
 at the given `path`, starting with the initial user state `ustate`.
 In case no unicode byte order marks are found, the file data is assumed to be encoded with the given `encoding`.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnStream``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``1,System.String,System.IO.Stream,System.Text.Encoding)">
<summary>
 `runParserOnStream p ustate streamName stream encoding` runs the parser `p` on the content of
 the `System.IO.Stream` `stream`, starting with the initial user state `ustate`. The `streamName`
 is used in error messages to describe the source of the input (e.g. a file path) and may be empty.
 In case no unicode byte order marks are found, the stream data is assumed to be encoded with the given `encoding`.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnSubstring``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``1,System.String,System.String,System.Int32,System.Int32)">
<summary>
 `runParserOnSubstring p ustate streamName str index count` runs the parser `p` directly on the content
 of the string `str` between the indices `index` (inclusive) and `index + count` (exclusive),
 starting with the initial user state `ustate`. The `streamName` is used in error messages to describe
 the source of the input (e.g. a file path) and may be empty.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnString``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``1,System.String,System.String)">
<summary>
 `runParserOnString p ustate streamName str` runs the parser `p` directly on the content of the string `str`,
 starting with the initial user state `ustate`. The `streamName` is used in error messages to describe
 the source of the input (e.g. a file path) and may be empty.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParser``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``1,System.String,FParsec.CharStream)">
<summary>
 `runParser p ustate streamName charStream` runs the parser `p` on the content of `charStream`,
 starting with the initial user state `ustate`. The `streamName` is used in error messages
 to describe the source of the input (e.g. a file path) and may be empty.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
 This function *does not* dispose the `CharStream` after use.
</summary>
</member>
<member name="T:FParsec.CharParsers">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FParsec.Error.ParserError.WriteTo(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{System.IO.TextWriter,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.Position,Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.Unit}}}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Writes a string representation of the `ParserError` to the given `TextWriter` value.

 The format of the position information can be customized by specifying the `positionPrinter`
 argument. The given function is expected to print a representation of the passed `Position` value
 to the passed `TextWriter` value. If possible, it should indent text lines with the passed string
 and take into account the maximum column count (including indention) passed as the last argument.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.WriteTo(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpFunc`2{System.String,FParsec.CharStream},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Writes a string representation of the `ParserError` to the given `TextWriter` value.

 For each error position `getStreamByName` is called with the `StreamName` of the `Position`.
 The returned `CharStream` must be `null` or contain the content of the `CharStream` for which
 the error was generated (at the original indices).

 If `getStreamByName` returns a non-null `CharStream`, the printed error position information is
 augmented with the line of text surrounding the error position, together with a &apos;^&apos;-marker
 pointing to the exact location of the error in the input stream.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.WriteTo(System.IO.TextWriter,FParsec.CharStream,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Writes a string representation of the `ParserError` to the given `TextWriter` value.

 The given `CharStream` must contain the content of the original `CharStream`
 for which this `ParserError` was generated (at the original indices).

 For each error location the printed position information is augmented
 with the line of text surrounding the error position, together with a &apos;^&apos;-marker
 pointing to the exact location of the error in the input stream.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.ToString(FParsec.CharStream)">
<summary>
 Returns a string representation of the `ParserError`.

 The given `CharStream` must contain the content of the original `CharStream`
 for which this `ParserError` was generated (at the original indices).

 For each error location the printed position information is augmented
 with the line of text surrounding the error position, together with a &apos;^&apos;-marker
 pointing to the exact location of the error in the input stream.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.ToString">
<summary>
 Returns a string representation of the `ParserError`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.Error.ParserError">
<summary>
 Represents a simple container type that brings together the position and error messages of a parser error.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.Error.ErrorMessageList">
<summary>
 Represents a list of error messages. The order of error messages in the list carries no meaning.
 Duplicate error messages and empty messages have no influence on ordering or equality comparison
 and are omitted when the list is converted to a set.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.OtherError">
<summary>
 User-defined parsers can return this `ErrorMessage` to report application-specific error data.
 The object argument contains the error data.
 To display `OtherError` values in error messages, you will have to define your own error printer,
 as the default printer ignores them.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.BacktrackPoint">
<summary>
 Parsers report this `ErrorMessage` when they backtracked after an error occurred.
 The constructor argument is the error (`Position` + `ErrorMessageList`) that occurred before the backtracking.
 This error message is mainly generated by the `attempt`, `&gt;&gt;?` and `.&gt;&gt;?` primitives.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.CompoundError">
<summary>
 Parsers report this `ErrorMessage` when a &quot;compound&quot; failed to parse.
 The constructor arguments are a label for the compound parser and
 the error (`Position` + `ErrorMessageList`) that caused the compound to fail to parse.
 This error message is mainly generated by the compound-labelling operator `&lt;??&gt;`.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.Message">
<summary>
 Parsers report this `ErrorMessage` when an error does not fit into the other categories.
 The constructor argument is a string containing the error message.
 This error message can be generated with the `fail` and `failFatally` primitives.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.UnexpectedStringCI">
<summary>
 Parsers report this `ErrorMessage` when they encounter an unexpected string constant (case-insensitive).
 The constructor argument is the unexpected string.
 This `ErrorMessage` is mainly generated by the `notFollowedByStringCI` parsers.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.UnexpectedString">
<summary>
 Parsers report this `ErrorMessage` when they encounter an unexpected string constant.
 The constructor argument is the unexpected string.
 This `ErrorMessage` is mainly generated by the `notFollowedByChar` and `notFollowedByString` parsers.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.Unexpected">
<summary>
 Parsers report this `ErrorMessage` when they encounter some unexpected input.
 The string argument describes the unexpected input.
 This `ErrorMessage` is mainly generated by the `notFollowedByL` primitive.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.ExpectedStringCI">
<summary>
 Parsers report this `ErrorMessage` when the input does not match an expected case-insensitive string constant.
 The constructor argument is the expected string constant.
 This `ErrorMessage` is mainly generated by the `pstringCI` parsers and its variants.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.ExpectedString">
<summary>
 Parsers report this `ErrorMessage` when the input does not match an expected string constant.
 The constructor argument is the expected string constant.
 This `ErrorMessage` is mainly generated by the `pchar` and `pstring` parsers and its variants.
</summary>
</member>
<member name="T:FParsec.Error.ErrorMessage.Expected">
<summary>
 Parsers report this `ErrorMessage` when the input does not match the expected input.
 The string argument describes the expected input.
 This error message can be generated with the labeling operator `&lt;?&gt;`.
</summary>
</member>
<member name="">

</member>
<member name="M:FParsec.Error._raiseInfiniteLoopException``2(System.String,FParsec.State{``0})">
<summary>
 Internal helper function that needs to be public because it gets called from inline functions.
</summary>
</member>
<member name="M:FParsec.Error.printErrorLine(FParsec.CharStream,System.Int64,System.IO.TextWriter,System.String,System.Int32)">
<summary>
 Prints the line of text surrounding the given index in the stream and
 marks the position of the index with a caret (^) on a second line.
 The output is indented with the given string and is restricted to the
 given columWidth (including the indention).
</summary>
</member>
<member name="M:FParsec.Error.mergeErrorsIfNeeded3``1(FParsec.State{``0},FParsec.Error.ErrorMessageList,FParsec.State{``0},FParsec.Error.ErrorMessageList,FParsec.State{``0},FParsec.Error.ErrorMessageList)">
<summary>
 `mergeErrorsIfNeeded3 veryOldState veryOldError oldState oldError newState newError` is equivalent to
 `mergeErrorsIfNeeded oldState (mergeErrorsIfNeeded veryOldState veryOldError oldState oldError) newState newError`.
</summary>
</member>
<member name="M:FParsec.Error.mergeErrorsIfNeeded``1(FParsec.State{``0},FParsec.Error.ErrorMessageList,FParsec.State{``0},FParsec.Error.ErrorMessageList)">
<summary>
 `mergeErrorsIfNeeded oldState oldError newState newError` is equivalent to
 `if newState &lt;&gt; State then newError else mergeErrors oldError newError`.
</summary>
</member>
<member name="M:FParsec.Error.mergeErrors(FParsec.Error.ErrorMessageList,FParsec.Error.ErrorMessageList)">
<summary>
 `mergeErrors error1 error2` is an inlined variant of `concatErrorMessages error1 error2`
 that avoids the call to `concatErrorMessages` if `error1` is empty (i.e. equals `NoErrorMessages`).
</summary>
</member>
<member name="M:FParsec.Error.concatErrorMessages(FParsec.Error.ErrorMessageList,FParsec.Error.ErrorMessageList)">
<summary>
 `concatErrorMessages error1 error2` concatenates the two error message lists `error1` and `error2`.
</summary>
</member>
<member name="M:FParsec.Error.compoundError``1(System.String,FParsec.State{``0},FParsec.Error.ErrorMessageList)">
<summary>
 `compoundError label state msgs` creates an `ErrorMessageList` with a single `CompoundError label state.Position msgs` message,
 except if `msgs` is an `ErrorMessageList` with a single `BacktrackPoint(pos2, msgs2)` message,
 in which case an `ErrorMessageList` with a single `CompoundError label pos2 msgs2` message is returned instead.
</summary>
</member>
<member name="M:FParsec.Error.backtrackError``1(FParsec.State{``0},FParsec.Error.ErrorMessageList)">
<summary>
 `backtrackError state msgs` creates an `ErrorMessageList` with a single `BacktrackPoint stat.Position msgs` message,
 except if `msgs` is already an `ErrorMessageList` with a single `BacktrackPoint(_, _)` message,
 in which case `msgs` is returned instead.
</summary>
</member>
<member name="M:FParsec.Error.otherError(System.IComparable)">
<summary>
 `otherError o` creates an `ErrorMessageList` with a single `OtherError o` message.
</summary>
</member>
<member name="M:FParsec.Error.messageError(System.String)">
<summary>
 `messageError msg` creates an `ErrorMessageList` with a single `Message msg` message.
</summary>
</member>
<member name="M:FParsec.Error.unexpectedStringCIError(System.String)">
<summary>
 `unexpectedStringCIError str` creates an `ErrorMessageList` with a single `UnexpectedStringCI str` message.
</summary>
</member>
<member name="M:FParsec.Error.unexpectedStringError(System.String)">
<summary>
 `unexpectedStringError str` creates an `ErrorMessageList` with a single `UnexpectedString str` message.
</summary>
</member>
<member name="M:FParsec.Error.unexpectedError(System.String)">
<summary>
 `unexpectedError label` creates an `ErrorMessageList` with a single `Unexpected label` message.
</summary>
</member>
<member name="M:FParsec.Error.expectedStringCIError(System.String)">
<summary>
 `expectedStringCIError str` creates an `ErrorMessageList` with a single `ExpectedStringCI str` message.
</summary>
</member>
<member name="M:FParsec.Error.expectedStringError(System.String)">
<summary>
 `expectedStringError str` creates an `ErrorMessageList` with a single `ExpectedString str` message.
</summary>
</member>
<member name="M:FParsec.Error.expectedError(System.String)">
<summary>
 `expectedError label` creates an `ErrorMessageList` with a single `Expected label` message.
</summary>
</member>
<member name="T:FParsec.Error">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FParsec.Internals.LineWrapper.Break(System.String)">
<summary>
 breaks a string into multiple lines along text element boundaries.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.Internals.LineWrapper">
<summary>
 A primitive pretty printer.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.Internals">

</member>
<member name="P:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.TermParser(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{`1},FParsec.Primitives.Reply{`0,`1}})">
<summary>
 This parser is called to parse the terms in between the operators. There is no default,
 so you must set this parser before you can call the `ExpressionParser`.
 Note that the term parser is also expected to parse any whitespace after a term.
</summary>
</member>
<member name="P:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.OperatorConflictHandler(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{`1},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.OperatorPrecedenceParser.PrecedenceParserOp{`0,`1},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{`1},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.OperatorPrecedenceParser.PrecedenceParserOp{`0,`1},System.String}}}})">
<summary>
 This function is called when the precedence parser encounters two conflicting
 operators in the parser input.
 If the conflict handler returns `null` or an empty string, the operators are
 parsed as if both were (left-)associative, otherwise a parser error with the
 returned message is generated.
 The default handler will always generate an error message.
</summary>
</member>
<member name="P:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.TermParser">
<summary>
 This parser is called to parse the terms in between the operators. There is no default,
 so you must set this parser before you can call the `ExpressionParser`.
 Note that the term parser is also expected to parse any whitespace after a term.
</summary>
</member>
<member name="P:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.Operators">
<summary>
 Returns a sequence with a snapshot of the operators currently registered with the `OperatorPrecedenceParser`.
</summary>
</member>
<member name="P:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.OperatorConflictHandler">
<summary>
 This function is called when the precedence parser encounters two conflicting
 operators in the parser input.
 If the conflict handler returns `null` or an empty string, the operators are
 parsed as if both were (left-)associative, otherwise a parser error with the
 returned message is generated.
 The default handler will always generate an error message.
</summary>
</member>
<member name="P:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.ExpressionParser">
<summary>
 The expression parser. This is a constant closure that forwards all work to an
 internal instance method, so that the expression parser always reflects the latest
 configuration of the `OperatorPrecedenceParser` instance.
 The parser can be safely called from different threads as long as the
 `OperatorPrecedenceParser` instance is not mutated at the same time.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.RemoveTernaryOp(System.String,System.String)">
<summary>
 Removes the ternary operator with the given strings from the grammar.
 Returns `false` if no ternary operator with these strings was previously registered, otherwise `true`.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.RemovePrefixOp(System.String)">
<summary>
 Removes the prefix operator with the given string from the grammar.
 Returns `false` if no prefix operator with that string was previously registered, otherwise `true`.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.RemovePostfixOp(System.String)">
<summary>
 Removes the postfix operator with the given string from the grammar.
 Returns `false` if no postfix operator with that string was previously registered, otherwise `true`.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.RemoveOperator(FParsec.OperatorPrecedenceParser.PrecedenceParserOp{`0,`1})">
<summary>
 Removes the given operator from the grammar.
 Returns `false` if the operator was not previously registered, otherwise true.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.RemoveInfixOp(System.String)">
<summary>
 Removes the infix operator with the given string from the grammar.
 Returns `false` if no infix operator with that string was previously registered, otherwise `true`.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.AddOperators(System.Collections.Generic.IEnumerable{FParsec.OperatorPrecedenceParser.PrecedenceParserOp{`0,`1}})">
<summary>
 Calls `AddOperator` with each operator in the given sequence.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.AddOperator(FParsec.OperatorPrecedenceParser.PrecedenceParserOp{`0,`1})">
<summary>
 Adds an operator to the grammar.
 Raises an `ArgumentException` if the operator definition conflicts with a
 a previous definition or contains empty strings or a non-positive precedence.
</summary>
</member>
<member name="M:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{FParsec.OperatorPrecedenceParser.PrecedenceParserOp{`0,`1}}})">
<summary>
 Constructs an OperatorPrecedenceParser instance and optionally adds the given operators.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.OperatorPrecedenceParser`2">
<summary>
 Represents a dynamically configurable parser for parsing expressions involving
 prefix, postfix, infix and ternary operators of different precedence and associativity.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.TernaryOp'">
<summary>
 TernaryOp&apos;(op1String, wsAfterOp1Parser, op2String, wsAfterOp2Parser, precedence, associativity, f)
 The states passed as arguments to the function are captured immediately before
 the first and second operator strings are parsed and contain the positions of the operators.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.InfixOp'">
<summary>
 InfixOp&apos;(opString, wsAfterOpParser, precedence, associativity, f),
 The state passed as an argument to the function is captured immediately before
 the operator string is parsed and contains the position of the operator.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.PostfixOp'">
<summary>
 PostfixOp&apos;(opString, wsAfterOpParser, precedence, isAssociative, f),
 The state passed as an argument to the function is captured immediately before
 the operator string is parsed and contains the position of the operator.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.PrefixOp'">
<summary>
 PrefixOp&apos;(opString, wsAfterOpParser, precedence, isAssociative, f),
 The state passed as an argument to the function is captured immediately before
 the operator string is parsed and contains the position of the operator.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.TernaryOp">
<summary>
 TernaryOp(op1String, wsAfterOp1Parser, op2String, wsAfterOp2Parser, precedence, associativity, f)
 represents a ternary operator definition for the `OperatorPrecedenceParser`.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.InfixOp">
<summary>
 InfixOp(opString, wsAfterOpParser, precedence, associativity, f)
 represents an infix operator definition for the `OperatorPrecedenceParser`.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.PostfixOp">
<summary>
 PostfixOp(opString, wsAfterOpParser, precedence, isAssociative, f)
 represents a postfix operator definition for the `OperatorPrecedenceParser`.
</summary>
</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2.PrefixOp">
<summary>
 PrefixOp(opString, wsAfterOpParser, precedence, isAssociative, f)
 represents a prefix operator definition for the `OperatorPrecedenceParser`.
</summary>
</member>
<member name="">

</member>
<member name="T:FParsec.OperatorPrecedenceParser.PrecedenceParserOp`2">
<summary>
 This union type is used to define operators for an OperatorPrecedenceParser.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.OperatorPrecedenceParser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FParsec.Primitives.ParserCombinator">
<summary>
 The type of the &quot;builder object&quot; that can be used to build parsers with
 F#&apos;s &quot;computation expression&quot; syntax a.k.a. &quot;workflow&quot; syntax.
</summary>
</member>
<member name="T:FParsec.Primitives.Parser`2">
<summary>
 The type of the parser functions supported by FParsec combinators.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:FParsec.Primitives.Reply`2.Result">
<summary>
 If Status &lt;&gt; Ok then the value of the Result field is undefined and may be equal to Unchecked.defaultof&lt;&apos;TResult&gt;.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FParsec.Primitives.createParserForwardedToRef``2">
<summary>
 `let p, pRef = createParserForwardedToRef()` creates a parser `p` that forwards all
 calls to the parser in the reference cell `pRef`. Initially, `pRef` holds a reference
 to a dummy parser that raises an exception on any invocation.
</summary>
</member>
<member name="P:FParsec.Primitives.parse">
<summary>
 The builder object for building parsers using F#&apos;s computation expression syntax.
</summary>
</member>
<member name="M:FParsec.Primitives.chainr``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``1}},``0)">
<summary>
 The parser `chainr p op defVal` is equivalent to `chainr1 p op &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.chainr1``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``1}})">
<summary>
 The parser `chainr1 p op` parses one or more occurrences of `p` separated by `op`
 (in EBNF notation: `p (op p)*`).
 It returns the value obtained by *right* associative application of all functions
 returned by `op` to the results returned by `p`,
 i.e. `f1 x_1 (f_2 x_2 (... (f_n x_n x_n+1) ...))`,
 where `f_1` to `f_n` are the functions returned by the parser `op` and
 `x_1` to `x_n+1` are the values returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.chainl``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``1}},``0)">
<summary>
 The parser `chainl p op defVal` is equivalent to `chainl1 p op &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.chainl1``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``1}})">
<summary>
 The parser `chainl1 p op` parses one or more occurrences of `p` separated by `op`
 (in EBNF notation: `p (op p)*`).
 It returns the value obtained by *left* associative application of all functions
 returned by `op` to the results returned by `p`,
 i.e. `f_n (... (f_2 (f_1 x_1 x_2) x_3) ...) x_n+1`,
 where `f_1` to `f_n` are the functions returned by the parser `op` and
 `x_1` to `x_n+1` are the values returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyTillFoldApply``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}},Microsoft.FSharp.Core.FSharpFunc`2{``2,``3},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``4},FParsec.Primitives.Reply{``0,``4}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``4},FParsec.Primitives.Reply{``2,``4}})">
<summary>
 The parser `manyTillFoldApply f1 foldF applyF emptyF p sep` expands to an optimized implementation of

 pipe2 (many (notFollowedBy endp &gt;&gt;. p)) endp
       (fun lst b -&gt;
            match lst with
            | []     -&gt; emptyF b
            | hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)) b
</summary>
</member>
<member name="M:FParsec.Primitives.manyTillReduce``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `manyTillReduce f defVal p endp` is an optimized implementation of

 manyTill p endp
 |&gt;&gt; function
     | []  -&gt; defVal
     | lst -&gt; List.reduce f
</summary>
</member>
<member name="M:FParsec.Primitives.manyTillFold``4(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``3,``2}})">
<summary>
 The parser `manyTillFold acc0 f p endp` is an optimized implementation of `manyTill p endp |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyTillRev``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `manyTillRev p endp` is an optimized implementation of `manyTill p endp |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipManyTill``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `skipManyTill p endp` is an optimized implementation of `manyTill p endp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyTill``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `manyTill p endp` repeatedly applies the parser `p`
 while `endp` does not succeed.
 It stops at the parser state returned by `endp` and
 returns a list of the results returned by `p`.
 `manyTill p endp` is an optimized implementation of `many (notFollowedBy endp &gt;&gt;. p) .&gt;&gt; endp`
 that doesn&apos;t have to apply `endp` twice at the end of the sequence.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy1FoldApply``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``0,``3}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``4,``3}})">
<summary>
 The parser `sepEndBy1FoldApply f1 foldF applyF p sep` expands to an optimized implementation of
 `sepEndBy1 p |&gt;&gt; function hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy1Reduce``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepEndBy1Reduce f p sep` is an optimized implementation of
 `sepEndBy1 p sep |&gt;&gt; List.reduce f`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy1Fold``4(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``3,``2}})">
<summary>
 The parser `sepEndByFold acc0 f p sep` is an optimized implementation of
 `sepEndBy p sep |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy1Rev``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepEndBy1Rev p sep` is an optimized implementation of `sepEndBy p sep |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepEndBy1``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `skipSepEndBy p sep` is an optimized implementation of `sepEndBy p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy1``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepEndBy1 p sep` parses *one* or more occurrences of `p` separated and
 optionally ended by `sep` (in EBNF notation: `p (sep p)* sep?`).
 It returns a list of the results returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndByFoldApply``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``0,``3}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``4,``3}})">
<summary>
 The parser `sepEndByFoldApply f1 foldF applyF emptyF p sep` expands to an optimized implementation of

 sepEndBy p sep
 |&gt;&gt; function
     | []     -&gt; emptyF ()
     | hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndByReduce``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepEndByReduce f defVal p sep` is an optimized implementation of
 `(sepEndBy1 p sep |&gt;&gt; List.Reduce f) &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndByFold``4(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``3,``2}})">
<summary>
 The parser `sepEndByFold acc0 f p sep` is an optimized implementation of
 `sepEndBy p sep |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndByRev``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepEndByRev p sep` is an optimized implementation of `sepEndBy p sep |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepEndBy``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `skipSepEndBy p sep` is an optimized implementation of `sepEndBy p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepEndBy p sep` parses *zero* or more occurrences of `p` separated and
 optionally ended by `sep` (in EBNF notation: `(p (sep p)* sep?)?`).
 It returns a list of the results returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy1FoldApply``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``0,``3}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``4,``3}})">
<summary>
 The parser `sepBy1FoldApply f1 foldF applyF p sep` expands to an optimized implementation of
 `sepBy1 p |&gt;&gt; function hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy1Reduce``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepBy1Reduce f p sep` is an optimized implementation of
 `sepBy1 p sep |&gt;&gt; List.reduce f`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy1Fold``4(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``3,``2}})">
<summary>
 The parser `sepByFold acc0 f p sep` is an optimized implementation of
 `sepBy1 p sep |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy1Rev``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepBy1Rev p sep` is an optimized implementation of `sepBy1 p sep |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepBy1``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `skipSepBy1 p sep` is an optimized implementation of `sepBy1 p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy1``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepBy1 p sep` parses *one* or more occurrences of `p` separated by `sep`
 (in EBNF notation: `p (sep p)*`).
</summary>
</member>
<member name="M:FParsec.Primitives.sepByFoldApply``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``0,``3}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``4,``3}})">
<summary>
 The parser `sepByFoldApply f1 foldF applyF emptyF p sep` expands to an optimized implementation of

 sepBy p sep
 |&gt;&gt; function
     | []     -&gt; emptyF ()
     | hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)
</summary>
</member>
<member name="M:FParsec.Primitives.sepByReduce``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepByReduce f defVal p sep` is an optimized implementation of
 `(sepBy1 p sep |&gt;&gt; List.Reduce f) &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepByFold``4(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``3,``2}})">
<summary>
 The parser `sepByFold acc0 f p sep` is an optimized implementation of
 `sepBy p sep |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepByRev``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepByRev p sep` is an optimized implementation of `sepBy p sep |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepBy``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `skipSepBy p sep` is an optimized implementation of `sepBy p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `sepBy p sep` parses *zero* or more occurrences of `p` separated by `sep`
 (in EBNF notation: `(p (sep p)*)?`).
</summary>
</member>
<member name="M:FParsec.Primitives.many1FoldApply2``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``3},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``4},FParsec.Primitives.Reply{``0,``4}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``4},FParsec.Primitives.Reply{``2,``4}})">
<summary>
 The parser `many1FoldApply2 f1 foldF applyF p1 p` expands to an optimized implementation of
 `pipe2 p1 (many p) (fun hd tl -&gt; applyF (List.fold foldF (f1 hd) tl))`
</summary>
</member>
<member name="M:FParsec.Primitives.many1FoldApply``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``0,``3}})">
<summary>
 The parser `many1FoldApply f1 foldF applyF p` expands to an optimized implementation of
 `many1 p |&gt;&gt; function hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyFoldApply2``5(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``3},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``3},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``4},FParsec.Primitives.Reply{``0,``4}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``4},FParsec.Primitives.Reply{``2,``4}})">
<summary>
 The parser `manyFoldApply2 f1 foldF applyF emptyF p1 p` expands to an optimized implementation of

 pipe2 p1 (many p) (fun hd tl -&gt; hd::tl) &lt;|&gt;% []
 |&gt;&gt; function
     | []     -&gt; emptyF ()
     | hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)
</summary>
</member>
<member name="M:FParsec.Primitives.manyFoldApply``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``3},FParsec.Primitives.Reply{``0,``3}})">
<summary>
 The parser `manyFoldApply f1 foldF applyF emptyF p` expands to an optimized implementation of

 many p
 |&gt;&gt; function
     | []     -&gt; emptyF ()
     | hd::tl -&gt; applyF (List.fold foldF (f1 hd) tl)
</summary>
</member>
<member name="M:FParsec.Primitives.many1Reduce``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `many1Reduce f` is an optimized implementation of
 `many1 p |&gt;&gt; List.reduce f`.
</summary>
</member>
<member name="M:FParsec.Primitives.many1Fold``3(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}})">
<summary>
 The parser `many1Fold acc0 f p` is an optimized implementation of
 `many1 p |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.many1Rev``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `many1Rev p` is an optimized implementation of `many1 p |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipMany1``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `skipMany1 p` is an optimized implementation of `many1 p |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.many1``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `many1 p` behaves like `many p`, except that it requires `p` to succeed at least one time.
 `many1 p` is an optimized implementation of `pipe2 p (many p) (fun hd tl -&gt; hd::tl)`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyReduce``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `manyReduce f defVal p` is an optimized implementation of
 `(many1 p |&gt;&gt; List.reduce f) &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyFold``3(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``2},FParsec.Primitives.Reply{``1,``2}})">
<summary>
 The parser `manyFold acc0 f p` is an optimized implementation of
 `many p |&gt;&gt; List.fold f acc0`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyRev``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `manyRev p` is an optimized implementation of `many p |&gt;&gt; List.rev`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipMany``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `skipMany p` is an optimized implementation of `many p |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.many``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `many p` repeatedly applies the parser `p` until `p` fails.
 It returns a list of the results returned by `p`.
 At the end of the sequence `p` must fail without changing the state and without
 signalling a `FatalError`, otherwise `many p` fails with the error reported by `p`.
 `many p` tries to guard against an infinite loop by throwing an exception
 if `p` succeeds without changing the parser state.
</summary>
</member>
<member name="M:FParsec.Primitives.skipArray``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `skipArray n p` is an optimized implementation of `parray n p |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.parray``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `parray n p` parses `n` occurences of `p` and
 returns the returns the results in an array.
 For example, `parray 3 p` is equivalent to `pipe3 p p p (fun a b c -&gt; [|a;b;c|])`.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple5``6(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``4,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``5,``1}})">
<summary>
 The parser `tuple5 p1 p2 p3 p4 p5` applies the parsers `p1`, `p2`, `p3`, `p4` and `p5` in sequence and
 returns the results in a tuple.
 `tuple5 p1 p2 p3 p4 p5` is equivalent to `pipe5 p1 p2 p3 p4 p5 (fun a b c d e -&gt; (a, b, c, d, e))`
</summary>
</member>
<member name="M:FParsec.Primitives.tuple4``5(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``4,``1}})">
<summary>
 The parser `tuple4 p1 p2 p3 p4` applies the parsers `p1`, `p2`, `p3` and `p4` in sequence and
 returns the results in a tuple.
 `tuple4 p1 p2 p3 p4` is equivalent to `pipe4 p1 p2 p3 p4 (fun a b c d -&gt; (a, b, c, d))`.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple3``4(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}})">
<summary>
 The parser `tuple3 p1 p2 p3` applies the parsers `p1`, `p2` and `p3` in sequence and
 returns the results in a tuple.
 `tuple3 p1 p2 p3` is equivalent to `pipe3 p1 p2 p3 (fun a b c -&gt; (a, b, c))`.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple2``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `tuple2 p1 p2` applies the parsers `p1` and `p2` in sequence and
 returns the results in a tuple.
 `tuple2 p1 p2` is equivalent to `pipe2 p1 p2 (fun a b -&gt; (a, b))`.
</summary>
</member>
<member name="M:FParsec.Primitives.failFatally``2(System.String)">
<summary>
 The parser `failFatally msg` always fails with a `messageError msg`. It signals a
 FatalError, so that no error recovery is attempted (except via backtracking constructs).
 `failFatally msg` is equivalent to `fun state -&gt; Reply(FatalError, messageError msg, state)`.
</summary>
</member>
<member name="M:FParsec.Primitives.fail``2(System.String)">
<summary>
 The parser `fail msg` always fails with a `messageError msg`.
 The error message will be displayed together with other error messages generated for
 the same input position.
 `fail msg` is equivalent to `fun state -&gt; Reply(Error, messageError msg, state)`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessQmarkQmarkGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},System.String)">
<summary>
 The parser `p &lt;??&gt; label` behaves like `p &lt;?&gt; label`, except that when `p` fails
 with a changed state (for example because `p` consumed input before it failed),
 a `CompoundError` message is generated with both the given string `label` and the
 error messages generated by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessQmarkGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},System.String)">
<summary>
 The parser `p &lt;?&gt; label` applies the parser `p`. If the output state returned by `p`
 equals the input state (usually because `p` failed), the error messages are replaced
 with `expectError label`.
</summary>
</member>
<member name="M:FParsec.Primitives.lookAhead``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `lookAhead p` parses `p` and restores the original input state afterwards.
 In case `p` fails, the error messages are wrapped in a `BacktrackError`.
 If it succeeds, any error messages are discarded. Fatal errors are turned into normal errors.
</summary>
</member>
<member name="M:FParsec.Primitives.notFollowedByL``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},System.String)">
<summary>
 The parser `notFollowedByL p` behaves like `notFollowedBy p`,
 except that it returns an `Unexpected label` error message when the parser `p` fails.
</summary>
</member>
<member name="M:FParsec.Primitives.notFollowedBy``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `notFollowedBy p` succeeds if the parser `p` fails to parse at the current position.
 Otherwise it fails with a non-fatal error. This parser never changes the parser state.
 If the parser `notFollowedBy p` fails, it returns no descriptive error message.
 Hence it should only be used together with other parsers that take care of a potential error.
 Alternatively, `notFollowedByL p label` can be used to ensure a more descriptive error message.
</summary>
</member>
<member name="M:FParsec.Primitives.followedByL``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},System.String)">
<summary>
 The parser `followedByL p` behaves like `followedBy p`,
 except that it returns an `Expected label` error message when the parser `p` fails.
</summary>
</member>
<member name="M:FParsec.Primitives.followedBy``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `followedBy p` succeeds if the parser `p` succeeds at the current position.
 Otherwise it fails with a non-fatal error. This parser never changes the parser state.
 If the parser `followedBy p` fails, it returns no descriptive error message.
 Hence it should only be used together with other parsers that take care of a potential error.
 Alternatively, `followedByL p label` can be used to ensure a more descriptive error message.
</summary>
</member>
<member name="M:FParsec.Primitives.op_DotGreaterGreaterQmark``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `p1 .&gt;&gt;? p2` behaves like `p1 .&gt;&gt; p2`, except that it will backtrack
 to the beginning if `p2` fails with a non-fatal error and without changing state,
 even if `p1` has changed the state.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterQmark``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `p1 &gt;&gt;? p2` behaves like `p1 &gt;&gt;. p2`, except that it will backtrack
 to the beginning if `p2` fails with a non-fatal error and without changing state,
 even if `p1` has changed the state.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterEqualsQmark``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}}})">
<summary>
 The parser `p &gt;&gt;=? f` behaves like `p &gt;&gt;= f`, except that it will
 backtrack to the beginning if the parser returned by `f` fails with a
 non-fatal error and with an unchanged state, even if `p` has changed the state.
</summary>
</member>
<member name="M:FParsec.Primitives.attempt``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `attempt p` applies the parser `p`.
 If `p` fails with an output state different from the input state,
 `attempt p` will backtrack to the original input state and then report a non-fatal error.
 Thus, `attempt p1 &lt;|&gt; p2` will continue to try to parse `p2` even
 if `p1` fails after consuming input or if `p1` fails with a fatal error.
</summary>
</member>
<member name="M:FParsec.Primitives.optional``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `optional p` skips over an optional occurrence of `p`.
 `optional p` is an optimized implementation of `(p &gt;&gt;% ()) &lt;|&gt;% ()`.
</summary>
</member>
<member name="M:FParsec.Primitives.opt``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `opt p` parses an optional occurrence of `p` as an option value.
 `opt p` is an optimized implementation of `(p |&gt;&gt; Some) &lt;|&gt;% None`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessBarGreaterPercent``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``0)">
<summary>
 The parser `p &lt;|&gt;% x` is equivalent to `p &lt;|&gt; preturn x`.
</summary>
</member>
<member name="M:FParsec.Primitives.choiceL``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}}},System.String)">
<summary>
 The parser `choiceL ps label` is an optimized implementation of `choice ps &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.Primitives.choice``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}}})">
<summary>
 The parser `choice ps` is an optimized implementation of `p1 &lt;|&gt; p2 &lt;|&gt; ... &lt;|&gt; pn &lt;|&gt; pzero`,
 where `p1` ... `pn` are the parsers in the sequence `ps`
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessBarGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}})">
<summary>
 The parser `p1 &lt;|&gt; p2` first applies the parser `p1`.
 If `p1` succeeds, the result of `p1` is returned.
 If `p1` fails with a non-fatal error and with an *output state equal to the input state*,
 the parser `p2` is applied.
 Note: The stream position is part of the state, so if `p1` fails after consuming input,
 `p2` will not be applied.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe5``7(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``4,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``5,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``3,Microsoft.FSharp.Core.FSharpFunc`2{``4,Microsoft.FSharp.Core.FSharpFunc`2{``5,``6}}}}})">
<summary>
 The parser `pipe5 p1 p2 p3 p4 p5 f` applies the parsers `p1`, `p2`, `p3`, `p4` and `p5` in sequence.
 It returns the result of the function application `f a b c d e`, where `a`, `b`, `c`, `d` and `e` are the results returned by `p1`, `p2`, `p3`, `p4` and `p5`.
 `pipe5 p1 p2 p3 p4 p5 f` is an optimized implementation of `p1 &gt;&gt;= fun a -&gt; p2 &gt;&gt;= fun b -&gt; p3 &gt;&gt;= fun c -&gt; p4 &gt;&gt;= fun d -&gt; p5 &gt;&gt;= fun e -&gt; preturn (f a b c d e)`.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe4``6(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``4,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``3,Microsoft.FSharp.Core.FSharpFunc`2{``4,``5}}}})">
<summary>
 The parser `pipe4 p1 p2 p3 p4 f` applies the parsers `p1`, `p2`, `p3` and `p4` in sequence.
 It returns the result `f a b c d`, where `a`, `b`, `c` and `d` are the results returned by `p1`, `p2`, `p3` and `p4`.
 `pipe4 p1 p2 p3 p4 f` is an optimized implementation of `p1 &gt;&gt;= fun a -&gt; p2 &gt;&gt;= fun b -&gt; p3 &gt;&gt;= fun c -&gt; p4 &gt;&gt;= fun d -&gt; preturn (f a b c d)`.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe3``5(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``3,``4}}})">
<summary>
 The parser `pipe3 p1 p2 p3 f` applies the parsers `p1`, `p2` and `p3` in sequence.
 It returns the result `f a b c`, where `a`, `b` and `c` are the results returned by `p1`, `p2` and `p3`.
 `pipe3 p1 p2 p3 f` is an optimized implementation of `p1 &gt;&gt;= fun a -&gt; p2 &gt;&gt;= fun b -&gt; p3 &gt;&gt;= fun c -&gt; preturn (f a b c)`.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe2``4(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}})">
<summary>
 The parser `pipe2 p1 p2 f` applies the parsers `p1` and `p2` in sequence.
 It returns the result `f a b`, where `a` and `b` are the results returned by `p1` and `p2`.
 `pipe2 p1 p2 f` is an optimized implementation of `p1 &gt;&gt;= fun a -&gt; p2 &gt;&gt;= fun b -&gt; preturn (f a b)`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_BarGreaterGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 The parser `p |&gt;&gt; f` applies the parser `p` and
 returns the result `f x`,  where `x` is the result returned by `p`.
 `p |&gt;&gt; f` is an optimized implementation of `p &gt;&gt;= fun x -&gt; preturn (f x)`.
</summary>
</member>
<member name="M:FParsec.Primitives.between``4(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``3,``1}})">
<summary>
 The parser `between popen pclose p` applies the parsers `pOpen`, `p` and `pEnd` in sequence.
 It returns the result of `p`.
 `between popen pclose p` is an optimized implementation of `popen &gt;&gt;. (p .&gt;&gt; pclose)`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_DotGreaterGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `p1 .&gt;&gt; p2` applies the parsers `p1` and `p2` in sequence. It returns the result of `p1`.
 `p1 .&gt;&gt; p2` is an optimized implementation of `p1 &gt;&gt;= fun x -&gt; p2 &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}})">
<summary>
 The parser `p1 &gt;&gt;. p2` applies the parsers `p1` and `p2` in sequence. It returns the result of `p2`.
 `p1 &gt;&gt;. p2` is an optimized implementation of `p1 &gt;&gt;= fun _ -&gt; p2`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterPercent``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},``2)">
<summary>
 The parser `p &gt;&gt;% x` applies the parser `p` and returns the result `x`.
 `p &gt;&gt;% x` is an optimized implementation of `p &gt;&gt;= fun _ -&gt; preturn x`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{FParsec.State{``1},FParsec.Primitives.Reply{``2,``1}}})">
<summary>
 The parser `p &gt;&gt;= f` first applies the parser `p`, then applies the function `f`
 to the result returned by `p` and finally applies the parser returned by `f`.
</summary>
</member>
<member name="M:FParsec.Primitives.pzero``2">
<summary>
 The parser `pzero` always fails with an empty error message list, i.e. an unspecified error.
 `pzero x` is defined as `fun state -&gt; Reply(Error, NoErrorMessages, state)`.
</summary>
</member>
<member name="M:FParsec.Primitives.preturn``2(``0)">
<summary>
 The parser `preturn x` always succeeds with the result `x` (without changing the parser state).
 `preturn x` is defined as `fun state -&gt; Reply(x, state)`.
</summary>
</member>
<member name="P:FParsec.Primitives.FatalError">
<summary>
 The parser failed and no error recovery (except after backtracking) should be tried.
</summary>
</member>
<member name="P:FParsec.Primitives.Error">
<summary>
 The parser failed.
</summary>
</member>
<member name="P:FParsec.Primitives.Ok">
<summary>
 The parser succeeded.
</summary>
</member>
<member name="T:FParsec.Primitives">

</member>
</members>
</doc>
