<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FParsecCS</name>
    </assembly>
    <members>
        <member name="P:FParsec.State`1.LineBegin">
            <summary>The stream index of the first char in the line, i.e. Index - Column + 1.</summary>
        </member>
        <member name="P:FParsec.State`1.Column">
            <summary>The 1-based index of the UTF16 char in the line, i.e. Index - LineBegin + 1.</summary>
        </member>
        <member name="T:FParsec.StringBuffer">
            <summary>A substring of a pinned string on the large object heap.
            StringBuffers are cached in a pool and hence need to be properly disposed.</summary>
        </member>
        <member name="F:FParsec.StringBuffer.Allocated">
            <summary>Sum of the lengths of all currently allocated StringBuffers</summary>
        </member>
        <member name="F:FParsec.StringBuffer.PoolSegment.Last">
            <summary>the last allocated segment</summary>
        </member>
        <member name="P:FParsec.StringBuffer.PoolSegment.Size">
            <summary>String.Length - x, where x > 0</summary>
        </member>
        <member name="M:FParsec.Helper.DetectPreamble(System.Byte[],System.Int32,System.Text.Encoding@,System.Boolean)">
            <summary>Detects the presence of an encoding preamble in the first count bytes of the byte buffer.
            If detectEncoding is false, this function only searches for the preamble of the given default encoding,
            otherwise also for any of the standard unicode byte order marks (UTF-8, UTF-16 LE/BE, UTF-32 LE/BE).
            If an encoding different from the given default encoding is detected, the new encoding
            is assigned to the encoding reference.
            Returns the number of bytes in the detected preamble, or 0 if no preamble is detected.
            </summary>
        </member>
        <member name="M:FParsec.Helper.CountTextElements(System.String)">
            <summary>A faster implementation of System.Globalization.StringInfo(str).LengthInTextElements.</summary>
        </member>
        <member name="T:FParsec.Helper.UTF8EncodingWithNonSerializableDecoder.NonSerializableUTF8Decoder">
            <summary>Needed for Test.CharStreamTests and can't be implemented in F#.</summary>
        </member>
        <member name="T:FParsec.Cloning.CloneImage">
            <summary>Contains the serialized state of on object.</summary>
        </member>
        <member name="M:FParsec.Cloning.CloneImage.CreateClone">
            <summary>Deserializes the object state into a new object.</summary>
        </member>
        <member name="M:FParsec.Cloning.Cloner.Create(System.Type)">
            <summary>Returns a cloner for the given <em>run-time</em> type.</summary>
            <param name="type">The run-time type of the objects to clone. The type must be serializable.</param>
        </member>
        <member name="M:FParsec.Cloning.Cloner.Clone(System.Object)">
            <summary>Copies the given object using the serialization API.</summary>
            <param name="instance">The object to clone. instance.GetType() must equal the Type the Cloner was created for.</param>
        </member>
        <member name="M:FParsec.Cloning.Cloner.CaptureImage(System.Object)">
            <summary>Returns an image of the given object instance.</summary>
            <param name="instance">The object to capture an image of.</param>
        </member>
        <member name="M:FParsec.Cloning.Cloner.GetSerializedFields(System.Type,System.Boolean@)">
            <summary>Returns the public and non-public fields of the type (and its base types),
            except fields with the NonSerialized attribute. In the returned array fields from
            derived types come before fields from base types.</summary>
        </member>
        <member name="M:FParsec.Cloning.Cloner.FindStronglyConnectedComponents(FParsec.Cloning.Cloner.State[])">
            <summary>Fills the Strongly StronglyConnectedComponent fields of the
            states passed in the array. Returns an array mapping each state to an
            integer component identifier.
            </summary>
            <param name="states">The object states to traverse. The object with array index
            0 is ignored. All other objects are assumed to be reachable from the object
            with array index 1.</param>
        </member>
        <member name="M:FParsec.Cloning.Cloner.ComputeTopologicalOrder(FParsec.Cloning.Cloner.State[])">
            <summary>Returns an array with the topologically sorted indices of the states.
            In the returned array the indices of states belonging to the same strongly
            connected component are adjacent (but the order within a strongly connected
            component is undefined).
            </summary>
            <param name="states">The object states to traverse. The object with array index
            0 is ignored. All other objects are assumed to be reachable from the object
            with array index 1.</param>
        </member>
        <member name="F:FParsec.Cloning.Cloner.State.EventHandlers">
            <summary>May be null.</summary>
        </member>
        <member name="F:FParsec.Cloning.Cloner.State.ObjectIndices">
            <summary>Indices of nested objects in the object graph. May be null.</summary>
        </member>
        <member name="F:FParsec.Cloning.Cloner.State.StronglyConnectedComponent">
            <summary>May be null.</summary>
        </member>
        <member name="T:FParsec.CharStream">
            <summary>Provides access to the char content of a binary Stream (or a String) through
            an iterator-based interface that is especially well suited for parser applications.</summary>
        </member>
        <member name="F:FParsec.CharStream.BufferString">
            <summary>The string holding the char buffer, or null if the buffer is not part of a .NET string.</summary>
        </member>
        <member name="F:FParsec.CharStream.BufferStringPointer">
            <summary>A pointer to the beginning of BufferString, or null if BufferString is null.</summary>
        </member>
        <member name="F:FParsec.CharStream.BufferHandle">
            <summary>Holds the GCHandle for CharStreams directly constructed from strings or char arrays.</summary>
        </member>
        <member name="F:FParsec.CharStream.Buffer">
            <summary>Holds the StringBuffer for CharStreams constructed from a binary stream.</summary>
        </member>
        <member name="M:FParsec.CharStream.ReadAllRemainingCharsFromStream(System.Char*,System.Int32,System.Byte[],System.Int32,System.Int32,System.IO.Stream,System.Int64,System.Text.Decoder)">
            <summary>Reads all remaining chars into the given buffer. If the remaining stream
            content holds more than the given maximum number of chars, an exception will be thrown.</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Constructs a CharStream from the chars in the string argument between the indices index (inclusive) and index + length (exclusive).</summary>
            <exception cref="T:System.ArgumentNullException">chars is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">At least one of the following conditions is not satisfied: index ≥ 0, length ≥ 0 and index + length ≤ chars.Length.</exception>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.String,System.Int32,System.Int32,System.Int64)">
            <summary>Constructs a CharStream from the chars in the string argument between the indices index (inclusive) and index + length (exclusive). The first char in the stream is assigned the index streamBeginIndex.</summary>
            <exception cref="T:System.ArgumentNullException">chars is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">At least one of the following conditions is not satisfied: index ≥ 0, length ≥ 0, index + length ≤ chars.Length and 0 ≤ streamBeginIndex &lt; 2^60.</exception>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>Constructs a CharStream from the chars in the char array argument between the indices index (inclusive) and index + length (exclusive).</summary>
            <exception cref="T:System.ArgumentNullException">chars is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">At least one of the following conditions is not satisfied: index ≥ 0, length ≥ 0 and index + length ≤ chars.Length.</exception>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.Char[],System.Int32,System.Int32,System.Int64)">
            <summary>Constructs a CharStream from the chars in the char array argument between the indices index (inclusive) and index + length (exclusive). The first char in the stream is assigned the index streamBeginIndex.</summary>
            <exception cref="T:System.NullReferenceException">chars is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">At least one of the following conditions is not satisfied: index ≥ 0, length ≥ 0, index + length ≤ chars.Length and 0 ≤ streamBeginIndex &lt; 2^60.</exception>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.Char*,System.Int32)">
            <summary>Constructs a CharStream from the length chars at the pointer address.</summary>
            <exception cref="T:System.ArgumentNullException">chars is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">length is negative.</exception>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.Char*,System.Int32,System.Int64)">
            <summary>Constructs a CharStream from the length chars at the pointer address. The first char in the stream is assigned the index streamBeginIndex.</summary>
            <exception cref="T:System.ArgumentNullException">chars is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">At least one of the following conditions is not satisfied: length ≥ 0 and 0 ≤ streamBeginIndex &lt; 2^60.</exception>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.String,System.Text.Encoding)">
            <summary>Constructs a CharStream from the file at the given path.<br/>Is equivalent to CharStream(new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan), false, encoding, true, defaultBlockSize, defaultBlockSize/3, ((defaultBlockSize/3)*2)/3, defaultByteBufferLength).</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.String,System.Text.Encoding,System.Boolean)">
            <summary>Constructs a CharStream from the file at the given path.<br/>Is equivalent to CharStream(new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan), false, encoding, detectEncodingFromByteOrderMarks, defaultBlockSize, defaultBlockSize/3, ((defaultBlockSize/3)*2)/3, defaultByteBufferLength).</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Constructs a CharStream from the file at the given path.<br/>Is equivalent to CharStream(new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan), false, encoding, detectEncodingFromByteOrderMarks, blockSize, blockOverlap, minRegexSpace, byteBufferLength).</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>Constructs a CharStream from a byte Stream.<br/>Is equivalent to CharStream(stream, false, encoding, true, defaultBlockSize, defaultBlockSize/3, ((defaultBlockSize/3)*2)/3, defaultByteBufferLength).</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.IO.Stream,System.Boolean,System.Text.Encoding)">
            <summary>Constructs a CharStream from a byte Stream.<br/>Is equivalent to CharStream(stream, leaveOpen, encoding, true, defaultBlockSize, defaultBlockSize/3, ((defaultBlockSize/3)*2)/3, defaultByteBufferLength).</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.IO.Stream,System.Boolean,System.Text.Encoding,System.Boolean)">
            <summary>Constructs a CharStream from a byte Stream.<br/>Is equivalent to CharStream(stream, leaveOpen, encoding, detectEncodingFromByteOrderMarks, defaultBlockSize, defaultBlockSize/3, ((defaultBlockSize/3)*2)/3, defaultByteBufferLength).</summary>
        </member>
        <member name="M:FParsec.CharStream.#ctor(System.IO.Stream,System.Boolean,System.Text.Encoding,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Constructs a CharStream from a byte Stream.</summary>
            <param name="stream">The byte stream providing the input.</param>
            <param name="leaveOpen">Indicates whether the byte Stream should be left open when the CharStream has finished reading it.</param>
            <param name="encoding">The (default) Encoding used for decoding the byte Stream into chars.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether the constructor should detect the encoding from a unicode byte-order mark at the beginning of the stream. An encoding detected from a byte-order mark overrides the default encoding.</param>
            <param name="blockSize">The number of chars per block. The default is 3×2^16 ≈ 200k.</param>
            <param name="blockOverlap">The number of chars at the end of a block that are preserved when reading the next block into the char buffer. It must be less than blockSize/2, but not less than encoding.GetMaxCharCount(1). The default is blockSize/3.</param>
            <param name="minRegexSpace">The number of chars that are guaranteed to be visible to a regular expression when it is matched on the stream (assuming there are enough chars remaining in the stream). Must not be greater than blockOverlap. The default is 2/3 of blockOverlap.</param>
            <param name="byteBufferLength">The size of the byte buffer used for decoding purposes. The default is 2^12 = 4KB.</param>
        </member>
        <member name="F:FParsec.CharStream.DoNotRoundUpBlockSizeToSimplifyTesting">
            <summary>we modify this flag via reflection in the unit test</summary>
        </member>
        <member name="M:FParsec.CharStream.PositiveDistance(System.Char*,System.Char*)">
            <summary>an optimized version of end - begin, which assumes that 2^31 > end - begin >= 0. </summary>
        </member>
        <member name="M:FParsec.CharStream.Seek(System.Int64)">
            <summary>Returns an iterator pointing to the given index in the stream,
            or to the end of the stream if the indexed position lies beyond the last char in the stream.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The index is negative or less than the BeginIndex.</exception>
            <exception cref="T:System.NotSupportedException">Accessing the char with the given index requires seeking in the underlying byte stream, but the byte stream does not support seeking or the Encoding's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
            <exception cref="T:System.OutOfMemoryException">Can not allocate enough memory for the internal data structure.</exception>
            <exception cref="T:System.ObjectDisposedException">Method is called after the stream was disposed.</exception>
        </member>
        <member name="M:FParsec.CharStream.FoldCase(System.String)">
            <summary>Returns a case-folded copy of the string argument. All chars are mapped
            using the (non-Turkic) 1-to-1 case folding mappings (v. 5.1) for Unicode code
            points in the Basic Multilingual Plane, i.e. code points below 0x10000.
            If the argument is null, null is returned.</summary>
        </member>
        <member name="M:FParsec.CharStream.NormalizeNewlines(System.String)">
            <summary>Returns the given string with all occurrences of "\r\n" and "\r" replaced
            by "\n". If the argument is null, null is returned.</summary>
        </member>
        <member name="P:FParsec.CharStream.Encoding">
            <summary>The Encoding that is used for decoding the underlying byte stream, or
            System.Text.UnicodeEncoding in case the stream was directly constructed
            from a string.</summary>
        </member>
        <member name="P:FParsec.CharStream.Block">
            <summary>The current block in BufferString.</summary>
        </member>
        <member name="P:FParsec.CharStream.BufferCount">
            <summary>The number of chars in BufferString.</summary>
        </member>
        <member name="P:FParsec.CharStream.BeginIndex">
            <summary>The index of the first char in the stream, i.e. Begin.Index.
            This value is determined by the streamBeginIndex argument of some of the CharStream constructors.
            By default this value is 0.</summary>
        </member>
        <member name="P:FParsec.CharStream.EndIndex">
            <summary>The index of the last char of the stream plus 1,
            or Int64.MaxValue if the end of stream has not yet been detected.</summary>
        </member>
        <member name="P:FParsec.CharStream.Begin">
            <summary>An iterator pointing to the beginning of the stream (or to the end if the CharStream is empty).</summary>
        </member>
        <member name="F:FParsec.CharStream.BlockInfo.ByteIndex">
            <summary>the byte stream index of the first char in the block after the OverhangCharsAtBlockBegin</summary>
        </member>
        <member name="F:FParsec.CharStream.BlockInfo.ByteBufferIndex">
            <summary>the value of the CharStream's ByteBufferIndex before the block is read</summary>
        </member>
        <member name="F:FParsec.CharStream.BlockInfo.NumberOfBytesInOverlap">
            <summary>the number of bytes in the stream from ByteIndex to the first char after the OverhangCharsAfterOverlap</summary>
        </member>
        <member name="F:FParsec.CharStream.BlockInfo.LastCharInOverlap">
            <summary>the last char in the overlap with the previous block (used for integrity checking)</summary>
        </member>
        <member name="F:FParsec.CharStream.BlockInfo.OverhangCharsAtBlockBegin">
            <summary>chars at the block begin that were already read together with chars of the last block before the overlap</summary>
        </member>
        <member name="F:FParsec.CharStream.BlockInfo.OverhangCharsAfterOverlap">
            <summary>chars after the overlap with the previous block that were already read together with the overlap chars</summary>
        </member>
        <member name="T:FParsec.CharStream.Anchor">
            <summary>Represents the link between a CharStream and its Iterators.
            May be allocated on the unmanaged heap and holds a GCHandle, hence must be properly freed.</summary>
        </member>
        <member name="F:FParsec.CharStream.Anchor.LastBlock">
            <summary>The index of the last block of the stream, or Int32.MaxValue if the end of stream has not yet been detected.</summary>
        </member>
        <member name="F:FParsec.CharStream.Anchor.BufferBegin">
            <summary>Begin of the used part of the char buffer (stays constant). Is null if the CharStream is empty.</summary>
        </member>
        <member name="F:FParsec.CharStream.Anchor.BufferEnd">
            <summary>End of the used part of the char buffer (varies for a multi-block stream). Is null if the CharStream is empty.</summary>
        </member>
        <member name="T:FParsec.CharStream.MultiBlockData">
            <summary>Contains the data and methods needed in case the input byte stream
            is large enough to span multiple blocks of the CharStream.</summary>
        </member>
        <member name="F:FParsec.CharStream.MultiBlockData.RegexSpaceThreshold">
            <summary>BufferBegin + BlockSize - minRegexSpace</summary>
        </member>
        <member name="M:FParsec.CharStream.MultiBlockData.FillByteBuffer">
            <summary>Refills the ByteBuffer if no unused byte is remaining.
            Returns the number of unused bytes in the (refilled) ByteBuffer.</summary>
        </member>
        <member name="M:FParsec.CharStream.MultiBlockData.ClearAndRefillByteBuffer(System.Int32)">
            <summary>Refills the ByteBuffer starting at the given index. If the underlying byte
            stream contains enough bytes, the ByteBuffer is filled up to the ByteBuffer.Length.
            Returns the number of bytes available for consumption in the refilled ByteBuffer.</summary>
        </member>
        <member name="M:FParsec.CharStream.MultiBlockData.ReadCharsFromStream(System.Char*,System.Int32,System.String@)">
            <summary>Reads up to the given maximum number of chars into the given buffer.
            If more than the maximum number of chars have to be read from the stream in order to
            fill the buffer (due to	the way the Decoder API works), the overhang chars are
            returned through the output parameter.
            Returns a pointer to one char after the last char read.</summary>
        </member>
        <member name="M:FParsec.CharStream.MultiBlockData.ReadBlock(System.Int32)">
            <summary> Reads a block of chars (must be different from the current block)
            into the BufferString. Returns a pointer to the first char of the new block,
            or null if no chars could be read.</summary>
        </member>
        <member name="P:FParsec.CharStream.MultiBlockData.ByteIndex">
            <summary>The byte stream index of the first unused byte in the ByteBuffer.</summary>
        </member>
        <member name="T:FParsec.CharStream.Iterator">
            <summary>The iterator type for CharStreams.</summary>
        </member>
        <member name="F:FParsec.CharStream.Iterator.EndOfStreamChar">
            <summary>The char returned by Read() if the iterator has
            reached the end of the stream. The value is '\uFFFF'.</summary>
        </member>
        <member name="F:FParsec.CharStream.Iterator.Ptr">
            <summary>Pointer to the current char in the CharStream's buffer (if the CharStream's current block equals Block).</summary>
        </member>
        <member name="F:FParsec.CharStream.Iterator.Block">
            <summary>The buffer block for which Ptr is valid.</summary>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Advance(System.Int32)">
            <summary>Returns an Iterator that is advanced by offset chars. The Iterator can't
            move past the end of the stream, i.e. any position beyond the last char
            in the stream is interpreted as precisely one char beyond the last char.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The new position would lie before the beginning of the `CharStream`.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Advance(System.Int64)">
            <summary>Returns an Iterator that is advanced by offset chars. The Iterator can't
            move past the end of the stream, i.e. any position beyond the last char
            in the stream is interpreted as precisely one char beyond the last char.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The new position would lie before the beginning of the `CharStream`.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
            <exception cref="T:System.OutOfMemoryException">Can not allocate enough memory for the internal data structure.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Advance(System.UInt32)">
            <summary>Returns an Iterator that is advanced by offset chars. The Iterator can't
            move past the end of the stream, i.e. any position beyond the last char
            in the stream is interpreted as precisely one char beyond the last char.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator._Increment">
             <summary>Advances the Iterator *in-place* by 1 char and returns the char on the new position.
            `c &lt;- iter._Increment()` is equivalent to `iter &lt;- iter.Next; c &lt;- iter.Read()`.</summary>
             <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
             <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
             <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
             <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator._Increment(System.UInt32)">
            <summary>Advances the Iterator *in-place* by offset chars and returns the char on the new position.
            `c &lt;- iter._Increment(offset)` is an optimized implementation of `iter &lt;- iter.Advance(offset); c &lt;- iter.Read()`.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator._Decrement">
            <summary>Advances the Iterator *in-place* by -1 char and returns the char on the new position,
            except if the Iterator already points to the beginning of the CharStream,
            in which case the position does not change and the EndOfStreamChar ('\uFFFF') is returned.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator._Decrement(System.UInt32)">
            <summary>Advances the Iterator *in-place* by -offset chars and returns the char on the new position,
            except if the new position would lie before the beginning of the CharStream,
            in which case the Iterator is advanced to the beginning of the stream and the EndOfStreamChar ('\uFFFF') is returned.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator._AdvanceInPlace(System.Int32)">
            <summary>A helper routine for optimizing State methods</summary>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Peek">
            <summary>Is an optimized implementation of Next.Read().</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Peek(System.Int32)">
            <summary>Is an optimized implementation of Advance(offset).Read(),
            except that the EndOfStreamChar ('\uFFFF') is returned if Index + offset &lt; 0 (instead of an exception being thrown).</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Peek(System.UInt32)">
            <summary>Is an optimized implementation of Advance(offset).Read().</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Match(System.Char)">
            <summary>Returns true if and only if the char argument matches the char pointed to by the Iterator.
            At the end of the stream Match always returns false.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Match(System.String)">
            <summary>Returns true if chars matches the chars in the stream beginning with the char pointed to by the Iterator.
            If the chars do not match or if there are not enough chars remaining in the stream, false is returned.
            If chars is empty, true is returned.</summary>
            <exception cref="T:System.NullReferenceException">chars is null.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.MatchCaseFolded(System.String)">
            <summary>Returns true if caseFoldedChars matches the chars in the stream
            beginning with the char pointed to by the Iterator.
            The chars in the stream are case-folded before they are matched,
            while the chars in the string argument are assumed to already be case-folded.
            If the chars do not match or if there are not enough chars remaining in the stream, false is returned.
            If caseFoldedChars is empty, true is returned.</summary>
            <exception cref="T:System.NullReferenceException">caseFoldedChars is null.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Match(System.String,System.Int32,System.Int32)">
            <summary>Returns true if the chars in chars between the indices charsIndex (inclusive) and
            charsIndex + length (exclusive) match the chars in the stream beginning with the char pointed to by the Iterator.
            If the chars do not match or if there are not enough chars remaining in the stream, false is returned.
            If length is 0, true is returned.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">charsIndex is negative, length is negative or charsIndex + length &gt; chars.Length.</exception>
            <exception cref="T:System.NullReferenceException">chars is null.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Match(System.Char[],System.Int32,System.Int32)">
            <summary>Returns true if the chars in the char array between the indices charsIndex (inclusive) and
            charsIndex + length (exclusive) match the chars in the stream beginning with the char pointed to by the Iterator.
            If the chars do not match or if there are not enough chars remaining in the stream, false is returned.
            If length is 0, true is returned.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">charsIndex is negative, length is negative or charsIndex + length &gt; chars.Length.</exception>
            <exception cref="T:System.NullReferenceException">chars is null.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Match(System.Char*,System.Int32)">
            <summary>Returns true if the length chars at the pointer address match the chars
            in the stream beginning with the char pointed to by the Iterator.
            If the chars do not match or if there are not enough chars remaining in the stream,
            false is returned. If length is 0, true is returned.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">length is negative.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.MatchCaseFolded(System.Char*,System.Int32)">
            <summary>Returns true if the length chars at the pointer address match the chars
            in the stream beginning with the char pointed to by the Iterator.
            The chars in the stream are case-folded before they are matched,
            while the chars at the pointer address are assumed to already be case-folded.
            If the chars do not match or if there are not enough chars remaining in the stream,
            false is returned. If length is 0, true is returned.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">length is negative.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Match(System.Text.RegularExpressions.Regex)">
            <summary>Applies the given regular expression to stream chars beginning with the char pointed to by the Iterator.
            Returns the resulting Match object. (Not supported by CharStreams constructed from char arrays or pointers.)</summary>
            <remarks><para>For performance reasons you should specify the regular expression
            such that it can only match at the beginning of a string,
            for example by prepending "\A".</para>
            <para>For CharStreams constructed from large binary streams the regular expression is not applied
            to a string containing all the remaining chars in the stream. The minRegexSpace parameter
            of the CharStream constructors determines the minimum number of chars that are guaranteed
            to be visible to the regular expression.</para>
            <para>
            IMPORTANT:<br/>
            If the CharStream has been constructed from a System.IO.Stream or a file path, the regular expression is
            applied to an internal mutable buffer. Since the Match object may work lazily, i.e. compute matched strings
            not before they are needed, you need to retrieve all the required information from the Match object before
            you continue to access the CharStream, otherwise you might get invalid results.</para>
            </remarks>
            <exception cref="T:System.NullReferenceException">regex is null.</exception>
            <exception cref="T:System.NotSupportedException">Two possible reasons: 1) The CharStream was constructed from a char array or char pointer, in which case it does not support regular expression matching.
            2) Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Read">
            <summary>Returns the stream char pointed to by the Iterator,
            or the EndOfStreamChar ('\uFFFF') if the Iterator has reached the end of the stream.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Read2">
            <summary>Is an optimized implementation of new TwoChars(Read(), Next.Read()).</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Read(System.Int32)">
            <summary>Returns a string with the length stream chars beginning with the char pointed to by the Iterator.
            If less than length chars are remaining in the stream, only the remaining chars are returned.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">length is negative.</exception>
            <exception cref="T:System.OutOfMemoryException">There is not enough memory for the string or the requested string is too large.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Read(System.Int32,System.Boolean)">
            <summary>Returns a string with the length stream chars beginning with the char pointed to by the Iterator.
            If less than length chars are remaining in the stream,
            only the remaining chars are returned, or an empty string if allOrEmpty is true.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">length is negative.</exception>
            <exception cref="T:System.OutOfMemoryException">There is not enough memory for the string or the requested string is too large.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Read(System.Char[],System.Int32,System.Int32)">
            <summary>Copies the length stream chars beginning with the char pointed to by the Iterator into buffer.
            The chars are written into buffer beginning at the index bufferIndex.
            If less than length chars are remaining in the stream, only the remaining chars are copied.
            Returns the actual number of chars copied.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">bufferIndex is negative, length is negative or bufferIndex + length &gt; buffer.Length.</exception>
            <exception cref="T:System.NullReferenceException">buffer is null.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.Read(System.Char*,System.Int32)">
            <summary>Copies the length stream chars beginning with the char pointed to by the Iterator into the buffer at the given pointer address.
            If less than length chars are remaining in the stream, only the remaining chars are copied.
            Returns the actual number of chars copied.</summary>
            <exception cref="T:System.NullReferenceException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">length is negative.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="M:FParsec.CharStream.Iterator.ReadUntil(FParsec.CharStream.Iterator)">
            <summary>Returns a string with all the chars in the stream between the position of this Iterator (inclusive)
            and the position of the Iterator in the argument (exclusive).
            If the Iterator argument does not point to a position after the position of this Iterator, the returned string is empty.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">iterToCharAfterLastInString belongs to a different CharStream.</exception>
            <exception cref="T:System.OutOfMemoryException">There is not enough memory for the string or the requested string is too large.</exception>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
        <member name="P:FParsec.CharStream.Iterator.Stream">
            <summary>The CharStream over which the Iterator iterates.</summary>
        </member>
        <member name="P:FParsec.CharStream.Iterator.IsBeginOfStream">
            <summary>Indicates whether the Iterator points to the beginning of the CharStream.
            If the CharStream is empty, this property is always true.</summary>
        </member>
        <member name="P:FParsec.CharStream.Iterator.IsEndOfStream">
            <summary>Indicates whether the Iterator points to the end of the CharStream,
            i.e. whether it points to one char beyond the last char in the CharStream.</summary>
        </member>
        <member name="P:FParsec.CharStream.Iterator.Index">
            <summary>The index of the stream char pointed to by the Iterator.</summary>
        </member>
        <member name="P:FParsec.CharStream.Iterator.Next">
            <summary>Returns an Iterator pointing to the next char in the stream. If the Iterator already
            has reached the end of the stream, i.e. if it points to one char beyond
            the last char, the same Iterator is returned.</summary>
            <exception cref="T:System.NotSupportedException">Seeking of the underlying byte stream is required, but the byte stream does not support seeking or the Encodings's Decoder is not serializable.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured.</exception>
            <exception cref="T:System.ArgumentException">The input stream contains invalid bytes and the encoding was constructed with the throwOnInvalidBytes option.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">The input stream contains invalid bytes for which the decoder fallback threw this exception.</exception>
        </member>
    </members>
</doc>
